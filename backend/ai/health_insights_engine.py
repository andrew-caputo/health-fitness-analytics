"""
Health Insights Engine - Core AI Analytics for Multi-Source Health Data

This module provides AI-powered health insights by analyzing data from multiple sources
including HealthKit, OAuth2 integrations, and file uploads. It generates personalized
recommendations, identifies patterns, and provides actionable health insights.
"""

import numpy as np
import pandas as pd
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
from enum import Enum
import logging
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_, func

from core.database import get_db
from core.models import HealthMetricUnified, User
from .correlation_analyzer import CorrelationAnalyzer
from .pattern_recognition import PatternRecognizer
from .anomaly_detector import AnomalyDetector
from .recommendation_engine import RecommendationEngine

logger = logging.getLogger(__name__)


class InsightType(Enum):
    """Types of health insights that can be generated"""
    CORRELATION = "correlation"
    TREND = "trend"
    ANOMALY = "anomaly"
    RECOMMENDATION = "recommendation"
    ACHIEVEMENT = "achievement"
    WARNING = "warning"
    PATTERN = "pattern"


class InsightPriority(Enum):
    """Priority levels for health insights"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


@dataclass
class HealthInsight:
    """Represents a health insight generated by the AI engine"""
    id: str
    user_id: int
    insight_type: InsightType
    priority: InsightPriority
    title: str
    description: str
    data_sources: List[str]
    metrics_involved: List[str]
    confidence_score: float
    actionable_recommendations: List[str]
    supporting_data: Dict[str, Any]
    created_at: datetime
    expires_at: Optional[datetime] = None


@dataclass
class HealthScore:
    """Overall health score with component breakdowns"""
    overall_score: float
    activity_score: float
    sleep_score: float
    nutrition_score: float
    heart_health_score: float
    consistency_score: float
    trend_score: float
    last_updated: datetime


class HealthInsightsEngine:
    """
    Core AI engine for generating health insights from multi-source data
    """
    
    def __init__(self):
        self.correlation_analyzer = CorrelationAnalyzer()
        self.pattern_recognizer = PatternRecognizer()
        self.anomaly_detector = AnomalyDetector()
        self.recommendation_engine = RecommendationEngine()
        
    def generate_comprehensive_insights(
        self, 
        user_id: int, 
        days_back: int = 30,
        db: Session = None
    ) -> List[HealthInsight]:
        """
        Generate comprehensive health insights for a user
        
        Args:
            user_id: User ID to generate insights for
            days_back: Number of days of historical data to analyze
            db: Database session
            
        Returns:
            List of health insights ordered by priority
        """
        if db is None:
            db = next(get_db())
            
        try:
            # Get user's health data
            health_data = self._get_user_health_data(user_id, days_back, db)
            
            if not health_data:
                logger.warning(f"No health data found for user {user_id}")
                return []
            
            insights = []
            
            # Generate different types of insights
            insights.extend(self._generate_correlation_insights(user_id, health_data))
            insights.extend(self._generate_trend_insights(user_id, health_data))
            insights.extend(self._generate_anomaly_insights(user_id, health_data))
            insights.extend(self._generate_pattern_insights(user_id, health_data))
            insights.extend(self._generate_achievement_insights(user_id, health_data))
            insights.extend(self._generate_recommendation_insights(user_id, health_data))
            
            # Sort by priority and confidence
            insights.sort(key=lambda x: (x.priority.value, -x.confidence_score))
            
            logger.info(f"Generated {len(insights)} insights for user {user_id}")
            return insights
            
        except Exception as e:
            logger.error(f"Error generating insights for user {user_id}: {str(e)}")
            return []
    
    def calculate_health_score(
        self, 
        user_id: int, 
        days_back: int = 30,
        db: Session = None
    ) -> Optional[HealthScore]:
        """
        Calculate comprehensive health score for a user
        
        Args:
            user_id: User ID to calculate score for
            days_back: Number of days of data to include
            db: Database session
            
        Returns:
            HealthScore object or None if insufficient data
        """
        if db is None:
            db = next(get_db())
            
        try:
            health_data = self._get_user_health_data(user_id, days_back, db)
            
            if not health_data:
                return None
            
            # Calculate component scores
            activity_score = self._calculate_activity_score(health_data)
            sleep_score = self._calculate_sleep_score(health_data)
            nutrition_score = self._calculate_nutrition_score(health_data)
            heart_health_score = self._calculate_heart_health_score(health_data)
            consistency_score = self._calculate_consistency_score(health_data)
            trend_score = self._calculate_trend_score(health_data)
            
            # Calculate weighted overall score
            weights = {
                'activity': 0.25,
                'sleep': 0.20,
                'nutrition': 0.20,
                'heart_health': 0.15,
                'consistency': 0.10,
                'trend': 0.10
            }
            
            overall_score = (
                activity_score * weights['activity'] +
                sleep_score * weights['sleep'] +
                nutrition_score * weights['nutrition'] +
                heart_health_score * weights['heart_health'] +
                consistency_score * weights['consistency'] +
                trend_score * weights['trend']
            )
            
            return HealthScore(
                overall_score=round(overall_score, 1),
                activity_score=round(activity_score, 1),
                sleep_score=round(sleep_score, 1),
                nutrition_score=round(nutrition_score, 1),
                heart_health_score=round(heart_health_score, 1),
                consistency_score=round(consistency_score, 1),
                trend_score=round(trend_score, 1),
                last_updated=datetime.utcnow()
            )
            
        except Exception as e:
            logger.error(f"Error calculating health score for user {user_id}: {str(e)}")
            return None
    
    def _get_user_health_data(
        self, 
        user_id: int, 
        days_back: int, 
        db: Session
    ) -> pd.DataFrame:
        """Get user's health data as pandas DataFrame"""
        end_date = datetime.utcnow()
        start_date = end_date - timedelta(days=days_back)
        
        # Query health metrics
        metrics = db.query(HealthMetricUnified).filter(
            and_(
                HealthMetricUnified.user_id == user_id,
                HealthMetricUnified.recorded_at >= start_date,
                HealthMetricUnified.recorded_at <= end_date
            )
        ).all()
        
        if not metrics:
            return pd.DataFrame()
        
        # Convert to DataFrame
        data = []
        for metric in metrics:
            data.append({
                'metric_type': metric.metric_type,
                'value': metric.value,
                'unit': metric.unit,
                'source_type': metric.source_type,
                'recorded_at': metric.recorded_at,
                'metadata': metric.metadata or {}
            })
        
        return pd.DataFrame(data)
    
    def _generate_correlation_insights(
        self, 
        user_id: int, 
        health_data: pd.DataFrame
    ) -> List[HealthInsight]:
        """Generate insights based on correlations between metrics"""
        insights = []
        
        try:
            correlations = self.correlation_analyzer.find_significant_correlations(health_data)
            
            for correlation in correlations:
                if correlation['strength'] > 0.6:  # Strong correlation
                    insight = HealthInsight(
                        id=f"corr_{user_id}_{correlation['metric1']}_{correlation['metric2']}",
                        user_id=user_id,
                        insight_type=InsightType.CORRELATION,
                        priority=InsightPriority.MEDIUM,
                        title=f"Strong Connection: {correlation['metric1']} & {correlation['metric2']}",
                        description=f"Your {correlation['metric1']} shows a {correlation['strength']:.0%} correlation with {correlation['metric2']}. {correlation['interpretation']}",
                        data_sources=list(health_data['source_type'].unique()),
                        metrics_involved=[correlation['metric1'], correlation['metric2']],
                        confidence_score=correlation['strength'],
                        actionable_recommendations=correlation.get('recommendations', []),
                        supporting_data=correlation,
                        created_at=datetime.utcnow()
                    )
                    insights.append(insight)
        
        except Exception as e:
            logger.error(f"Error generating correlation insights: {str(e)}")
        
        return insights
    
    def _generate_trend_insights(
        self, 
        user_id: int, 
        health_data: pd.DataFrame
    ) -> List[HealthInsight]:
        """Generate insights based on trends in health metrics"""
        insights = []
        
        try:
            trends = self.pattern_recognizer.analyze_trends(health_data)
            
            for trend in trends:
                priority = InsightPriority.HIGH if abs(trend['slope']) > 0.5 else InsightPriority.MEDIUM
                
                direction = "improving" if trend['slope'] > 0 else "declining"
                
                insight = HealthInsight(
                    id=f"trend_{user_id}_{trend['metric']}",
                    user_id=user_id,
                    insight_type=InsightType.TREND,
                    priority=priority,
                    title=f"{trend['metric'].title()} is {direction}",
                    description=f"Your {trend['metric']} has been {direction} by {abs(trend['slope']):.1f}% over the past {trend['period']} days.",
                    data_sources=list(health_data['source_type'].unique()),
                    metrics_involved=[trend['metric']],
                    confidence_score=trend['confidence'],
                    actionable_recommendations=trend.get('recommendations', []),
                    supporting_data=trend,
                    created_at=datetime.utcnow()
                )
                insights.append(insight)
        
        except Exception as e:
            logger.error(f"Error generating trend insights: {str(e)}")
        
        return insights
    
    def _generate_anomaly_insights(
        self, 
        user_id: int, 
        health_data: pd.DataFrame
    ) -> List[HealthInsight]:
        """Generate insights based on anomalies in health data"""
        insights = []
        
        try:
            anomalies = self.anomaly_detector.detect_anomalies(health_data)
            
            for anomaly in anomalies:
                priority = InsightPriority.CRITICAL if anomaly['severity'] > 0.8 else InsightPriority.HIGH
                
                insight = HealthInsight(
                    id=f"anomaly_{user_id}_{anomaly['metric']}_{anomaly['date']}",
                    user_id=user_id,
                    insight_type=InsightType.ANOMALY,
                    priority=priority,
                    title=f"Unusual {anomaly['metric'].title()} Pattern Detected",
                    description=f"Your {anomaly['metric']} on {anomaly['date']} was {anomaly['deviation']:.1f}% different from your typical pattern.",
                    data_sources=list(health_data['source_type'].unique()),
                    metrics_involved=[anomaly['metric']],
                    confidence_score=anomaly['confidence'],
                    actionable_recommendations=anomaly.get('recommendations', []),
                    supporting_data=anomaly,
                    created_at=datetime.utcnow()
                )
                insights.append(insight)
        
        except Exception as e:
            logger.error(f"Error generating anomaly insights: {str(e)}")
        
        return insights
    
    def _generate_pattern_insights(
        self, 
        user_id: int, 
        health_data: pd.DataFrame
    ) -> List[HealthInsight]:
        """Generate insights based on patterns in health data"""
        insights = []
        
        try:
            patterns = self.pattern_recognizer.identify_patterns(health_data)
            
            for pattern in patterns:
                insight = HealthInsight(
                    id=f"pattern_{user_id}_{pattern['type']}",
                    user_id=user_id,
                    insight_type=InsightType.PATTERN,
                    priority=InsightPriority.MEDIUM,
                    title=f"{pattern['type'].title()} Pattern Identified",
                    description=pattern['description'],
                    data_sources=list(health_data['source_type'].unique()),
                    metrics_involved=pattern['metrics'],
                    confidence_score=pattern['confidence'],
                    actionable_recommendations=pattern.get('recommendations', []),
                    supporting_data=pattern,
                    created_at=datetime.utcnow()
                )
                insights.append(insight)
        
        except Exception as e:
            logger.error(f"Error generating pattern insights: {str(e)}")
        
        return insights
    
    def _generate_achievement_insights(
        self, 
        user_id: int, 
        health_data: pd.DataFrame
    ) -> List[HealthInsight]:
        """Generate insights based on achievements and milestones"""
        insights = []
        
        try:
            # Check for various achievements
            achievements = self._check_achievements(health_data)
            
            for achievement in achievements:
                insight = HealthInsight(
                    id=f"achievement_{user_id}_{achievement['type']}",
                    user_id=user_id,
                    insight_type=InsightType.ACHIEVEMENT,
                    priority=InsightPriority.MEDIUM,
                    title=f"🎉 {achievement['title']}",
                    description=achievement['description'],
                    data_sources=list(health_data['source_type'].unique()),
                    metrics_involved=achievement['metrics'],
                    confidence_score=1.0,
                    actionable_recommendations=achievement.get('recommendations', []),
                    supporting_data=achievement,
                    created_at=datetime.utcnow()
                )
                insights.append(insight)
        
        except Exception as e:
            logger.error(f"Error generating achievement insights: {str(e)}")
        
        return insights
    
    def _generate_recommendation_insights(
        self, 
        user_id: int, 
        health_data: pd.DataFrame
    ) -> List[HealthInsight]:
        """Generate personalized recommendations"""
        insights = []
        
        try:
            recommendations = self.recommendation_engine.generate_recommendations(health_data)
            
            for rec in recommendations:
                insight = HealthInsight(
                    id=f"rec_{user_id}_{rec['category']}",
                    user_id=user_id,
                    insight_type=InsightType.RECOMMENDATION,
                    priority=InsightPriority.MEDIUM,
                    title=rec['title'],
                    description=rec['description'],
                    data_sources=list(health_data['source_type'].unique()),
                    metrics_involved=rec['metrics'],
                    confidence_score=rec['confidence'],
                    actionable_recommendations=rec['actions'],
                    supporting_data=rec,
                    created_at=datetime.utcnow()
                )
                insights.append(insight)
        
        except Exception as e:
            logger.error(f"Error generating recommendation insights: {str(e)}")
        
        return insights
    
    def _calculate_activity_score(self, health_data: pd.DataFrame) -> float:
        """Calculate activity score based on steps, workouts, and active energy"""
        try:
            activity_metrics = health_data[
                health_data['metric_type'].isin(['activity_steps', 'activity_workouts', 'activity_active_energy'])
            ]
            
            if activity_metrics.empty:
                return 50.0  # Default score
            
            # Calculate based on consistency and targets
            steps_data = activity_metrics[activity_metrics['metric_type'] == 'activity_steps']
            if not steps_data.empty:
                avg_steps = steps_data['value'].mean()
                steps_score = min(100, (avg_steps / 10000) * 100)  # 10k steps = 100%
            else:
                steps_score = 50
            
            # Add workout frequency bonus
            workouts_data = activity_metrics[activity_metrics['metric_type'] == 'activity_workouts']
            workout_bonus = min(20, len(workouts_data) * 2)  # Up to 20 points for workouts
            
            return min(100, steps_score + workout_bonus)
            
        except Exception:
            return 50.0
    
    def _calculate_sleep_score(self, health_data: pd.DataFrame) -> float:
        """Calculate sleep score based on duration and consistency"""
        try:
            sleep_data = health_data[health_data['metric_type'] == 'sleep_duration']
            
            if sleep_data.empty:
                return 50.0
            
            avg_sleep = sleep_data['value'].mean()
            sleep_consistency = 100 - (sleep_data['value'].std() * 10)  # Penalize inconsistency
            
            # Optimal sleep is 7-9 hours
            if 7 <= avg_sleep <= 9:
                duration_score = 100
            elif avg_sleep < 7:
                duration_score = (avg_sleep / 7) * 100
            else:
                duration_score = max(50, 100 - ((avg_sleep - 9) * 10))
            
            return (duration_score * 0.7 + sleep_consistency * 0.3)
            
        except Exception:
            return 50.0
    
    def _calculate_nutrition_score(self, health_data: pd.DataFrame) -> float:
        """Calculate nutrition score based on calorie intake and balance"""
        try:
            nutrition_data = health_data[
                health_data['metric_type'].isin(['nutrition_calories', 'nutrition_protein', 'nutrition_carbs'])
            ]
            
            if nutrition_data.empty:
                return 50.0
            
            # Basic scoring based on data availability and consistency
            calories_data = nutrition_data[nutrition_data['metric_type'] == 'nutrition_calories']
            if not calories_data.empty:
                consistency = 100 - (calories_data['value'].std() / calories_data['value'].mean() * 100)
                return max(50, min(100, consistency))
            
            return 60.0  # Default for having some nutrition data
            
        except Exception:
            return 50.0
    
    def _calculate_heart_health_score(self, health_data: pd.DataFrame) -> float:
        """Calculate heart health score based on heart rate metrics"""
        try:
            heart_data = health_data[
                health_data['metric_type'].isin(['heart_rate', 'heart_rate_resting', 'heart_rate_variability'])
            ]
            
            if heart_data.empty:
                return 50.0
            
            # Basic scoring based on data availability
            resting_hr_data = heart_data[heart_data['metric_type'] == 'heart_rate_resting']
            if not resting_hr_data.empty:
                avg_resting_hr = resting_hr_data['value'].mean()
                # Optimal resting HR is 60-100 bpm
                if 60 <= avg_resting_hr <= 100:
                    return 90.0
                else:
                    return 70.0
            
            return 60.0  # Default for having some heart data
            
        except Exception:
            return 50.0
    
    def _calculate_consistency_score(self, health_data: pd.DataFrame) -> float:
        """Calculate consistency score based on data regularity"""
        try:
            # Count unique days with data
            health_data['date'] = pd.to_datetime(health_data['recorded_at']).dt.date
            unique_days = health_data['date'].nunique()
            
            # Calculate consistency based on data frequency
            total_days = (health_data['recorded_at'].max() - health_data['recorded_at'].min()).days + 1
            consistency = (unique_days / total_days) * 100
            
            return min(100, consistency)
            
        except Exception:
            return 50.0
    
    def _calculate_trend_score(self, health_data: pd.DataFrame) -> float:
        """Calculate trend score based on improvement over time"""
        try:
            # Analyze trends in key metrics
            key_metrics = ['activity_steps', 'sleep_duration', 'heart_rate_resting']
            trend_scores = []
            
            for metric in key_metrics:
                metric_data = health_data[health_data['metric_type'] == metric]
                if len(metric_data) > 7:  # Need at least a week of data
                    # Simple trend calculation
                    metric_data = metric_data.sort_values('recorded_at')
                    recent_avg = metric_data.tail(7)['value'].mean()
                    older_avg = metric_data.head(7)['value'].mean()
                    
                    if metric == 'heart_rate_resting':
                        # Lower is better for resting heart rate
                        trend = (older_avg - recent_avg) / older_avg * 100
                    else:
                        # Higher is better for steps and sleep
                        trend = (recent_avg - older_avg) / older_avg * 100
                    
                    trend_scores.append(max(0, min(100, 50 + trend * 5)))
            
            return np.mean(trend_scores) if trend_scores else 50.0
            
        except Exception:
            return 50.0
    
    def _check_achievements(self, health_data: pd.DataFrame) -> List[Dict[str, Any]]:
        """Check for various achievements and milestones"""
        achievements = []
        
        try:
            # Step achievements
            steps_data = health_data[health_data['metric_type'] == 'activity_steps']
            if not steps_data.empty:
                max_steps = steps_data['value'].max()
                if max_steps >= 20000:
                    achievements.append({
                        'type': 'steps_20k',
                        'title': 'Step Champion!',
                        'description': f'You walked {max_steps:,.0f} steps in a single day!',
                        'metrics': ['activity_steps']
                    })
                elif max_steps >= 15000:
                    achievements.append({
                        'type': 'steps_15k',
                        'title': 'Walking Warrior!',
                        'description': f'You achieved {max_steps:,.0f} steps in one day!',
                        'metrics': ['activity_steps']
                    })
            
            # Consistency achievements
            health_data['date'] = pd.to_datetime(health_data['recorded_at']).dt.date
            unique_days = health_data['date'].nunique()
            if unique_days >= 30:
                achievements.append({
                    'type': 'consistency_30',
                    'title': 'Consistency Master!',
                    'description': f'You\'ve tracked your health for {unique_days} days straight!',
                    'metrics': ['all']
                })
            elif unique_days >= 7:
                achievements.append({
                    'type': 'consistency_7',
                    'title': 'Week Warrior!',
                    'description': f'You\'ve maintained {unique_days} days of health tracking!',
                    'metrics': ['all']
                })
        
        except Exception as e:
            logger.error(f"Error checking achievements: {str(e)}")
        
        return achievements


# Global instance
health_insights_engine = HealthInsightsEngine() 